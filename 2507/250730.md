### 재귀함수

## 재귀함수
- 재귀함수 
    * 자기 자신을 호출하는 함수
    * 1부터 n까지의 모든 양의 정수를 곱한 값
    * 변수 사용이 줄어들며, 코드 가독성 높아짐?
    * 1개 이상의 base case(종료 상황) 존재
    - 사용하는 이유
        * 문제의 자연스러운 표현
        * 코드 간결성
        * 수학적 문제 해결
    - * 강조!!*
        * 종료 조건 명확히
        * 반복되는 호출이 종료 조건을 향하도록 하기
    
- 팩토리얼
    * *N! = Nx(N-1)*
    * 자기 자신을 재귀적으로 호출
    * 재귀 호출은 n이 0이 될때까지 반복, 종료 조건을 설정하여 재귀 호출 정지
    * 결과 이용하여 문제를 작은 단위의 문제로 분할, 분할된 문제들의 결과를 조합하여 최종 결과를 도출

    * def factorial(n):
        if n == 0:
            return 1
        else:
            return n * factorial(n-1)

      print(factorial(5)) == 120


- 내장 함수(bulit - in function)
    * 파이썬이 기본적으로 제공하는 함수(별도 import x)
    * 자주 사용되는 내장 함수

- map(function, iterable)
    * 순회 가능한 데이터구조의 모든 요소에 함수를 적용하고, 그 결과를 map object로 반환
    * (시험 안나옴)
        + map object는 이터레이터, 게으른 평가
        + 명령을 받는 즉시 계산을 수행하지 않는다
        + 메모리 효율성과 성능을 위해서다.
        + ex) 리스트에 100만개의 요소가 들어가 있다, map 적용시 한번에 100만개 만드는 건 메모리에 엄청난 낭비
        + ex) 결과를 한번에 저장안하고, 순차적으로 하나씩
        + yield = 제너레이터 활용하기 위한 리턴이다

- zip(*iterables)
    * 배열들을 세로로 묶어서 반환 (*는 몇개 들어올 지 모를때)
    * 회전 파트할 때 굉장히 유용함

- 함수 이름 작성 규칙
    * 기본
        * 소문자와 언더스코어 _ 사용
        * 동사로 시작-함수의 동작 설명
        * 약어 사용 지양
    * 함수 이름 구성 요소
        * 동사+명사
        * 동사 형용사 명사
        *  get/set 접두사 - 명사?
    * 단일 책임 원칙
        * 모든 객체(함수)는 하나의 명확한 목적과 책임만을 가져야 함
        * 여러 목적 필요하면 여러개 함수 만들고 여러 함수를 정리해서 순차적으로 실행하는 메인 함수 만드는게 좋음(유지보수면에서 큰 이점)
        * 
    * 함수 설계 원칙(영상 시간 3시간)
        * 명확한 목적
        * 책임 분리
        * 유지보수성

- 패킹(packing)
    * 여러 개의 값을 하나의 변수에 묶어서 담는 것
    * 변수에 담긴 값들은 튜플 형태로 묶임
    * (*=애스터리스크)이용해서 1,2,3,4,5,6 = a,*b,c 넣는다하면 
        a = 1, b = 2,3,4,5, c= 6  (*)갖고 있는 애가 여러개 가져감

- 언패킹(unpacking)
    * (*)두개 붙이면 딕셔너리의 키-값 쌍을 언패킹하여 함수의 *키워드 인자*로 전달

- 모듈
    * 한 파일로 묶인 변수와 함수의 모음
    * 특정한 기능을 하는 코드가 작성된 파이썬 파일

    * 모듈 가져오는 법
        * import 문 사용 (파일 전체)
            * 자주 사용, 속도 비슷, 어디서 가져온건지 쉽게 알 수 있음, 추천함
            * 코드가 길어짐;
        * from 절 사용 (모듈안에 특정 함수 지정 후 가져옴)
            * 충돌 가능성 높아짐
        * . 연산자 이용
    * 주의사항
        * 서로 다른 모듈이 같은 이름의 함수를 제공할 경우 문제 발생
        * 마지막에 import된 이름으로 대체됨
    * as 키워드
        * as 키워드 사용하여 별칭 *alias* 를 부여
            * 두개 이상의 모듈에서 동일한 이름 등 충돌 발생 방지

- 파이썬 표준 라이브러리
    * 파이썬 언어와 함께 제공되는 다양한 모듈의 패키지 모음
    * 설치 없이 바로 import 하여 사용
    * 사용 목적
        * 효율적으로 관리하고 재사용할 수 있도록 돕는 역할
    * 주의 사항
        * 라이선스 확인(누군가 악의적인 행동할 수도)
        * 보안(오래돼서 보안 취약할 수도)
        * 버전 충돌
- 패키지
    * 모듈들을 하나의 디렉토리에 모아 놓은 것
    * 패키지 사용하기
        * 각 패키지의 모듈을 import 하여 사용하기
        * from 패키지 import 모듈? 이해 안됨??????????????????
    * 외부 패키지
        * (파이썬 패키지 관리자)pip를 이용하여 설치 후 이용
        * 패키지 설치 pip install 패키지
    * 사용 목적
        * 효율적으로 관리하고 재사용할 수 있도록 돕는 역할
    * 주의 사항
        * 라이선스 확인(누군가 악의적인 행동할 수도)
        * 보안(오래돼서 보안 취약할 수도)
        * 버전 충돌

- 람다 표현식
    * 익명 함수(이름x)를 만드는데 사용되는 표현식 -> 한 줄로 간단한 함수를 정의
    * lambda 키워드
    
    * 람다 표현식
        addition = lambda(def) x, y(파라미터), : x + y(리턴)

- data structure
    * 데이터 구조(자료 구조)
        * 여러 데이터를 효과적으로 사용, 관리하기 위한 구조(str,list, dict 등)
    * 메서드
        * 객체에 속한 함수(객체의 상태를 조작하거나 동작을 수행)
    * 클래스 내부에 정의되는 함수
    * 클래스는 파이썬에서 '타입을 표현하는 방법'
    * 각 데이터 타입별로 다양한 기능을 가진 메서드
    * 호출 방법 -> 데이터 타입 객체.메서드()

- 시퀀스 데이터 구조
    * 문자열 조회/탐색 및 검증 메서드
        * s.find -> x의 첫번째위치 반환. 없으면 -1 반환
        * s.index -> x의 첫번째위치 반환. 없으면 오류 발생
            * 찾는 데이터 없으면 안될 때 일부러 터트려야 할때 사용
        * 둘 중 상황에 맞게 적절히 사용
    * 문자열 조작 메서드(새 문자열 반환)
        * .replace(old, new[, count])
            * 바꿀 대상 글자를 새로운 글자로 바꿔서 반환

        * 

        * .strip
            * 문자열의 시작과 끝에 있는 공백 혹은 지정한 문자를 제거

        * .split(sep = None, maxspilt =1)
            * sep를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를 반환
        
        * '(구분할 문자)'.join(구분할 것 ex)'-'.join(words)
            * 문자열을 연결한 문자열로 변환(리스트 형태로)
            * words = rqwr
            * new_text = '-'.join(words)
        * swapcase
    * 리스트
        * .append(추가할 것(통째로 추가됨))
        * .extend(분해해서 추가됨)
            * 반복 가능한 객체가 아니면 추가 불가
        * .insert(위치, 항목을 삽입)
        * .remove(항목)
            * 항목 찾아 삭제
        * .pop(항목)
            * 리스트에서 지정한 인덱스의 항목을 제거하고 반환
            * 항목을 작성하지 않을 경우 마지막 항목을 제거
            * 웬만하면 항목 없이 쓰자
        * .clear()
            * 리스트의 모든 항목을 삭제
        
        * .index(항목)
            * 첫번째로 일치하는 항목 위치 반환
        * .count(항목)
            * 리스트에서 항목의 개수를 반환
        * .reverse()
            * 리스트의 순서를 역순으로 변경
        * .sort()
            * 오름차순 정렬

- 객체와 참조
    * 가변 객체 : 생성 후 내용을 변경할 수 있는 객체
        * 리스트, 딕셔너리, 집합
    * 불변 객체 : 생성 후 내용을 변경할 수 없는 객체
        * 정수, 실수, 문자열, 튜플
    * 변수 할당의 의미
        * 파이썬에서 변수 할당은 객체에 대한 참조를 생성하는 과정
        * 변수는 객체의 메모리 주소를 가리키는 label 역할
        * 연산자를 사용하여 변수에 값을 할당
        * 새로운 객체가 생성되거나 참조
    * 메모리 참조 방식
        * 변수는 객체의 '메모리 주소'를 저장\
        * 여러 변수가 동일한 객체 참조 가능
    * id()
        * 함수를 사용해 객체의 메모리 주소 확인
        * is 연산자를 통해 두 변수가 같은 객체를 참조하는 지 확인 가능
        * 화이트해커 -> 어셈블리어도 알아야됨??
        * 가변은 동일값이어도 새로운 객체를 생성해서 주소가 다름
    * 가변/불변 메모리 관리 방식 3시간 10분
        * 가변 객체
        * 불변 객체
    * 이러한 동작 방식의 이유
        * 성능 최적화
        * 

- 얕은 복사
    * 객체의 최상위 요소만 새로운 메모리에 복사하는 방법
    * 내부에 중첩된 객체가 있다면 그 객체의 참조만 복사
    * 슬라이싱은 복사해서 새로운 객체 생성
    * 얕은 복사의 한계
        * 다차원 리스트에서 외부 주소는 복사해서 새로운 객체에 넣는데
            내부 주소는 그대로 가져와서 원본에 영향 줌

- 깊은 복사
    * deep copy
    * 객체의 모든 수준의 요소를 새로운 메모리에 복사하는 방법
    * 중첩된 객체까지 모두 새로운 객체로 생성됨
    * copy 모듈(import copy)해야 됨
    * *남발하면 안됨*

- 문자 유형 판별 메서드
    * isdecimal()
        * 문자열리 모두 숫자면 true
    * isdigit()
        * 
    * isnumeric
        * 
    *점점 범위 커짐*