# 분할정복
- 거듭 제곱
- 이진검색
# 정렬
- 병합 정렬, 퀵 정렬

## 분할 정복
- **대표적인 문제해결 기법**
    * 완전탐색
    * 탐욕 알고리즘
    * 분할정복
- 복잡한 문제를 더 작은 하위 문제들로 나누어 해결하는 알고리즘
- 대표적 예시
    * 거듭제곱
- 이진검색
    * 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행
    * 목적 키를 찾을때까지 이진 검색을 순환적으로 반복 수행
    * 검색 범위를 반으로 줄여가면서 빠르게 검색 수행
    * 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.
    * (탐색의 속도 = 정렬의 속도)
    * 검색 과정
        1. 자료의 중앙에 있는 원소 선택
        2. 중앙 원소의 값과 찾고자 하는 목표 값 비교
        3. 목표 값이 중앙 원소의 값보다 작으면 왼쪽, 크다면 오른쪽을 새로 검색 수행
        4. 목표값 찾을때까지 반복


## **병합정렬**
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용
    * 자료를 최소 단위의 문제(종료 조건)까지 나눈 후 차례대로 정렬
- 정렬 과정
    * 주어진 배열을 같은 크기의 두 부분의 배열로 나눔(재귀적으로 반복, 나눌 수 없을 때까지)
    * 시간
        * 0(nlogn)
    * 분할 단계
        * 최소 크기의 부분집합이 될 때까지 분할 작업 반복
    * 병합 단계
        * 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
- 병합 정렬 정리
    * 큰 데이터셋을 정렬할 때 유용, 안정적이고 예측 가능한 성능을 제공(데이터 작으면 선택정렬)
    * 최선/최악 시간복잡도(거의 무조건): O(nlogn)
        * 반으로 나누는 과정에서(log n) + 단계마다 비교 후 정렬(n), 성능 예측 가능
    * 안정성: O
    * 적응성: X
    * 제자리 정렬: X

## **퀵정렬**
- 주어진 리스트를 두 개로 분할하고, 각각을 정렬한다
- 퀵 정렬은 분할할 때, 기준 아이템을 중심으로 이보다 작은 것은 왼편, 같거나 큰 거는 오른편에 위치한다.
- 정렬 과정
    * 리스트에서 하나의 요소를 피벗(중심)으로 선택
    * 피벗보다 작은 건 왼쪽, 큰건 오른쪽 이동
    * 위 과정을 통해 최종 위치에 놓인 피벗을 기준으로 왼쪽/오른쪽 부분 배열에 대해 각각 퀵 정렬을 재귀적으로 수행
    * 부분 배열의 크기가 1 이하가 되면 재귀를 종료
- 피벗선택
    * 처음, 마지막, 중간(일반적으로 많이 쓰임), 랜덤, 중위값(일반적으로 많이 쓰임)
- 퀵 정렬 정리
    * 평균적으로 매우 빠르고, 메모리 효율이 좋음
    * 최악 시간 복잡도: O(n2)
    * 최선 시간 복잡도: O(nlogn)
    * 안정성: X
    * 적응성: O
    * 제자리 정렬: O
