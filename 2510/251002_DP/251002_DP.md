# DP
## 피보나치 수열의 재귀 호출
- 이전의 두 수 합을 다음 항으로 하는 수열을 피보나치라고 한다
- 피보나치 수열의 i 번째 값을 계산하는 함수 F를 정의하면 다음과 같다.
- 피보나치 수열의 i 번째 항을 반환하는 함수를 재귀함수로 구현할 수 있다.
- 재귀(하향식) : 엄청난 중복 호출이 존재해서 문제

## 메모이제이션
- 컴퓨터 프로그램을 실행할 때 **이전에 계산한 값을 메모리에 저장**해서 **매번 다시 계산하지 않도록 하여** 전체적인 실행속도를 빠르게 하는 기술
- 탑 다운 접근방식
- 추가적인 메모리 공간이 필요
- 재귀 함수 호출로 인한 시스템 호출 스택을 사용, 실행 속도 저하 또는 오버플로우 발생할 수 있음
- 해결책 ?

## DP
- 하향식(메모이제이션)  *다시보기* 피보나치 다음내용
    * 큰 문제를 작은 문제로 쪼갠다(하위 문제가 중복)
    * 분할 정복(하위 문제가 독립적)
    * 장점 : 코드로 구현 쉽게, 필요한 부분만 계산
    * 단점 : 재귀로 인한 스택오버플로우 가능성
- 상향식(DP)
    * 작은 문제부터 해결, 큰 문제를 해결(모든 걸 고려)
    * 탐욕(순간마다 선택)
    * 장점 : 재귀x, 메모리 효율
    * 단점 : 점화식, 불필요한 ?
- 현재에서 가장 보이는 것을 선택하는 것이 아닌, 과거의 데이터를 이용하여 현재의 데이터를 만들어내는 방식
- 그리디 알고리즘과 같이 최적화 문제를 해결하는 알고리즘이다.
- 입력 크기가 작은 부분 문제들을 모두 해결한 후 큰 크기의 부분 문제들을 해결하는 알고리즘
- DP 적용하기 위한 필수 조건
    * 중복 부분문제 구조 -> DP만의 특징
        * 최적 해를 이용하여 해결(그리디랑 동일)
        * 점화식을 사용
        * 이미 해결된 작은 문제들의 해들을 어떤 저장 공간에 저장
        * 중복된 계산을 피하게 된다.
    * 최적 부분문제 구조 -> 그리디의 특징
        * 최적화의 원칙을 만족해야함
        * 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 됨
- 최적의 원칙이 적용되지 않는 예 최장경로 문제
    * A에서 D 까지는 A -> C -> B > D 가 최장경로인데
    * A에서 C 까지는 A -> B -> C 임 위에랑 다름

- 피보나치 수 DP적용 *다시보기*
    * 부분 문제의 답으로부터 본 문제의 답을 얻을 수 있으므로 최적 부분 구조로 이루어짐
    * DP 알고리즘이 수행속도가 더 빠르다
        * 재귀와 달리 중복 계산 없음
        * 반복문 사용하기 때문에 함수 호출 x

## 이항계수
- 이항 정리 *다시보기*
    * 이항 다항식 (x+y)**n에 대해서, 전개한 각 항 의 계수 값을 구하는 정리이다

- 파스칼 삼각형
ㄹ