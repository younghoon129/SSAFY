# Branch
- 나뭇가지처럼 여러 갈래로 작업 공간을 나누어 독립적으로 작업할 수 있도록 도와주는 Git의 도구
- 장점
    - 독립된 개발 환경을 형성하기 때문에 원본(master)에 대해 안전
    - 하나의 작업은 하나의 브랜치로 나누어 진행되므로 체계적으로 협업과 개발이 가능
    - 손쉽게 브랜치를 생성하고 브랜치 사이를 이동할 수 있음
- 사용해야 하는 이유
    - 에러 해결하려면?
        - 브랜치를 통해 별도의 작업 공간을 만든다.
        - 브랜치에서 에러가 발생한 버전을 이전 버전으로 되돌리거나 삭제한다.
        - 브랜치는 완전하게 독립 되어있어서 작업 내용이 master 브랜치에 아무런 영향을 끼치지 못함.
        - 이후 에러가 해결되면 master 브랜치에 반영할 수 있다.
- master(main) 브랜치의 의미와 역할
    - 기본 브랜치
        - 저장소의 초기 상태를 나타내며, 일반적으로 프로젝트의 가장 최신 버전 또는 배포 가능한 안정적인 코드를 포함
    - 기준점
        - 다른 브랜치가 파생되는 기준점으로 사용
    - 변경사항 통합
        - 다른 브랜치에서 수정 완료 후, 코드 리뷰와 테스트 거쳐 master 브랜치에 병합
- git branch
    - git branch : 브랜치 목록 확인
    - git branch -r : 원격 저장소의 브랜치 목록 확인
    - git branch <브랜치 이름> : 새로운 브랜치 생성
    - git branch -d <브랜치 이름> : 브랜치 삭제 (병합된 브랜치만 삭제 가능)
    - git branch -D <브랜치 이름> : 브랜치 삭제 (강제 삭제)
- git switch
    - 현재 브랜치에서 다른 브랜치로 HEAD를 이동시키는 명령어
        - git switch <다른 브랜치 이름> : 다른 브랜치로 전환
        - git switch -c <브랜치 이름> : 새 브랜치 생성 후 전환
        - git switch -c <브랜치 이름> <commit ID> : 특정 커밋에서 새 브랜치 생성 후 전환
    - 주의사항:
        - switch 하기 전에 Working Directory 파일이 모두 버전 관리가 되고 있는지 반드시 확인
        - git add를 하지 않았던, 즉 Staging area 에 한 번도 올라가지 않은 새 파일은 git의 버전 관리를 받고 있지 않기 때문에 브랜치가 바뀌더라도 계속 유지
        - 그렇기 때문에 git switch를 하기 전, working directory의 모든 파일이 버전 관리 중 인지 확이 필요 
- HEAD
    - 현재 브랜치나 commit을 카리키는 포인터
    - 현재 내가 바라보는 브랜치

- Git Merge
    - 수신 브랜치(병합 브랜치를 가져오고자 하는 브랜치) 확인하기
        - git branch 명령어를 통해 HEAD가 올바른 수신 브랜치를 가리키는지 확인
        - 병합 진행 위치는 반드시 **수신 브랜치에게 진행**되어야 함
    - **최신 commit 상태 확인하기**
        - 수신 브랜치와 병합 브랜치 모두 최신 상태인지 확인
    - 종류
        1. Fast-Forward Merge
            - 브랜치를 '실제로' 병합하는 대신 현재 브랜치 상태를 대상 브랜치 상태로 이동시키는 작업(빨리 감기)
            - Merge 과정 없이 단순히 브랜치의 포인터가 앞으로 이동
        2. 3-Way Merge 
            - 병합하는 각 브랜치의 commit 2개와 공통 조상 commit 하나를 사용하여 병합하는 작업
    - 에러
        - Merge Conflict
            - 병합하려는 두 브랜치가 "동일한 파일의 동일한 부분"에서 변경된 후 병합 시 충돌이 발생하는 것
        - 충돌 표시하는 방식
            - 시각적 마커
                - <<<, ===, >>>
                - 일반적으로 ===마커 위 콘텐츠는 수신 브랜치, 아래 콘텐츠는 병합 브랜치
    - 충돌 해결 과정
        - 충돌하는 부분을 확인한 후 원하는 대로 충돌 내용을 수정
        - 병합을 완료할 준비가 되면 충돌하는 파일에서 git add 실행
        - 다음 git commit을 싱행하여 merge commit 생성
        - 병합 충돌은 3-Way-merge 인 경우에만 발생
- Feature Branch Workflow
    - 중앙 원본 저장소(Origin)는 하나, 기능 개발은 별도의 브랜치(Branch)에서
    - 모든 팀원이 하나의 중앙 원본 저장소(Origin)를 공유
    - master(main) 브랜치는 항상 안정적이고 배포 가능한 상태로 유지
    - 새로운 기능 개발이나 버그 수정은 반드시 feature/login, fix/header-bug와 같이 별도의 브랜치를 생성하여 진행
    - 작업이 완료되면, 중앙 저장소에 브랜치를 푸시(push)하고 풀 리퀘스트(pull Request, PR)를 통해 코드 리뷰를 거친 뒤 master 브랜치에 병합(merge)
    - 풀 리퀘스트
        - 내가 별도 브랜치(branch)에서 작업한 새로운 내용을, master와 같은 원본(또는 대상) 브랜치에 합병(Merge)해 달라고 공식적으로 요청하는 기능
        - 이는 단순한 '코드 합치기 요청'을 넘어, 협업을 위한 핵심 소통 도구로 사용 
    - PR의 핵심 목적: 코드 리뷰
        - 코드를 합치기 전에, 동료나 프로젝트 관리자(Maintainer)가 변경된 내용을 검토하고 피드백을 줄 수 있는 공식적인 장을 마련
    - 언제 사용?
        - 목적
            - master 브랜치의 안정성을 확보하고, 여러 기능 개발이 서로 충돌 없이 동시에 진행될 수 있도록 하기 위함
        - 사용 시점
            - 신뢰할 수 있는 팀원들이 하나의 프로젝트를 함께 개발할 때 가장 표준적으로 사용되는 방식
- Git Flow
    - 프로젝트를 운영할 때 원활한 협업과 버전관리를 위해 사용하는 브랜치 관리 전략
    - 꼭 주어진 방법에 따라 진행할 필요는 없으며, 현재 상황에 맞춰서 유연하게 사용하기(각 회사마다 다르게 운영될 수 있으나 큰 틀은 아래와 유사하게 운영)
    - master, h/<기능>, release, dev, f/<기능>
    - 미리 익숙해지기 위해서 협업하여 프로젝트 진행 시 도입하는 것을 추천
    - master(main) branch
        - 실제로 운영중인 서버 코드
        - 해당 브랜치에서 직접적인 코드 변경은 하지 않는 것을 권장
        - 다른 branch에서 병합 과정을 모두 진행한 후 master로 병합 후 배포 (최고 관리자)
    - dev branch
        - 실제로 운영중인 서버의 코드는 아니지만, 동일한 구성의 개발 서버 코드
        - dev 브랜치에서 직접적인 코드 변경은 하지 않는 것을 권장
        - 기능이 개발되면 develop에서 테스트를 진행하고, 테스트가 통과되면 release로 병합
    - release branch
        - 배포 날짜까지 배포 코드를 보관하는 브랜치
        - Dev 에서 테스트 완료 후에도 개발은 계속되기 때문에 배포 전까지 배포 코드를 보관
    - feature branch
        - 개발 서버에서 코드를 따와 각 개발자가 기능을 개발하는 branch
        - 자유롭게 개발하는 영역
        - Dev 브랜치에서 각 feature branch들이 합쳐질 때, complict으로 인한 에러를 조심
    - hotfix branch
        - 배포 시기와 상관없이 급하게 처리 해야하는 버그를 수정하는 브랜치
        - 버그 수정 후 바로 배포해야함으로 master branch에서 따와서 작업 진행
- Fork
    - 다른 사용자의 원격 저장소를 자신의 계정으로 복사하는 것
    - 내 저장소(Fork)에서 자유롭게 작업하고, 괜찮으면 원본에 제안(PR)하기
    - 중앙 원본 저장소(Upstream)에 직접 푸시(push)할 수 없음
    - 개발자는 먼저 중앙 저장소를 내 개인 계정으로 그대로 복제(Fork)하여, 완전히 독립된 나만의 원격 저장소(Origin)를 만듦
    - 모든 작업(브랜치 생성, 커밋)은 내 개인 저장소에서 자유롭게 이루어 짐
    - 작업이 완료되면, 내 저장소에서 중앙 원본 저장소로 풀 리퀘스트(PR)를 보내 제안
    - 원본 저장소의 관리자(Maintainer)가 이 제안을 검토하고 승인해야만 원본에 반영
    - 목적
        - 원본 프로젝트의 코드 품질과 안정성을 최고 수준으로 유지, 외부 기여자의 코드를 안전하게 검토하기 위함
    - 사용시점
        - 오픈 소스 프로젝트처럼, 핵심 관리자 그룹 외에 신뢰할 수 없는 다수의 외부 기여자가 프로젝트에 참여할 때 사용됨

- git stash -u
    - 현재 add 안올라간(git이 추적안한) 파일들 전부 창고행(임시 지움)
- git pop
    - 창고에 있는거 하나만 꺼냄