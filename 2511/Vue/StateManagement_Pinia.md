# State Management
- Props
  - 컴포넌트 구조가 5단계 이상 깊어질 경우 데이터를 전달하기 위해 모든 중간 컴포넌트를 거쳐야 함으로 복잡해짐
  - 수많은 emit 이벤트가 생겨 유지보수 어려워짐
- 컴포넌트 구성요소(서로 **단방향 데이터 흐름**으로 상호작용)
  - 상태(state)
    - 데이터(ref)
  - 뷰(view)
    - 시각화
  - 기능(Actions)
    - 정의된 동작(function)
- 상태 관리의 단순성(단방향 데이터 흐름)이 무너지는 시점
  - 여러 컴포넌트가 상태를 공유할 때
    - 여러 뷰가 동일한 상태에 종속되는 경우
      - 공유 상태를 공통 조상 컴포넌트로 **끌어올린** 다음, props로 여러 컴포넌트에 전달하는 방법
      - 컴포넌트 계층 구조가 깊어질수록 비효율적, 유지보수 어려움
    - 서로 다른 뷰의 기능이 동일한 상태를 변경시켜야 하는 경우
      - 발신(emit)된 이벤트를 통해 상태의 여러 복사본을 변경 및 동기화 하는 것
      - 관리의 패턴이 깨지기 쉽고 유지 관리할 수 없는 코드가 됨
- 해결 방법
  - 각 컴포넌트의 공유 상태를 추출하여, 전역에서 참조할 수 있는 저장소에서 관리
  - 이 저장소의 역할(Pinia)
    - Vue의 공식 상태 관리 라이브러리
  - 컴포넌트 트리의 하나의 큰 View가 되고 모든 컴포넌트는 트리 계층 구조에 관계 없이 상태에 접근하거나 기능을 사용할 수 있음

## State management library(Pinia)
- Pinia
  - 여러 컴포넌트가 공통 데이터를 중앙 저장소에서의 통합 관리를 도와주는 라이브러리
  - Props, emit 으로 복잡한 데이터 전달 안해도 됨, 어떤 컴포넌트든 이 중앙 저장소에 직접 접근하여 데이터 얻거나 수정 가능

## Pinia 구성요소
- store
  - 공통 데이터 관리하는 중앙 저장소
  - 모든 컴포넌트가 공유하는 상태, 기능이 작성됨
  - defineStore()의 반환 값(store)을 담는 변수의 이름은 use...Store 패턴 사용할 것을 권장(예: const useCounterStore)
  - defineStore()의 첫번째 인자는 애플리케이션 전체에 걸쳐 사용하는 store의 고유 ID(개발자가 정하는 거)
- state
  - ref()와 같은 역할
- getters
  - computed()와 같은 역할(캐싱)
- actions
  - methods와 같은 역할
  - state에서 정의하는 함수는 state 변경하는 역할
  - 컴포넌트에서 store의 state를 변경 가능하지만 권장X
    - 변경지점 분산될 경우 추적 어려움, 유지보수 코드 가독성 안좋음
  - store에 정의된 action 을 호출해서 간접적으로 변경할 것
- 반환 값
  - pinia의 상태들을 사용하려면 반드시 반환해야 함
  - private한 상태 속성 안가짐
- plugin
  - 추가 기능 제공하는 도구 및 모듈
  - 예시
    - localStorage에 저장하고 복원 해주는 플러그인(새로고침시 복구X)


## Pinia 구성요소 활용
- State
  - 각 컴포넌트 깊이에 관계 없이 store 인스턴스로 state에 접근하여 직접 읽고 쓸 수 있음
  - 만약 store에 state를 정의하지 않았다면 컴포넌트에서 새로 추가할 수 없음
- Actions
  - store의 모든 actions 또한 직접 접근 및 호출 가능
  - getters와 달리 state 조작, 비동기, API 호출이나 다른 로직을 진행할 수 있음

- 삭제 방법
  - findIndex를 활용해 하나만 찾아서 삭제
    - splice 사용(index, 1)
  - filter로 삭제하지 않아도 되는 것들만 모아서 재생성
    - todos.value = todos.value.filter(todo => todo.id !== selectedId)

- 수정 방법
  - todo 객체의 isDone 속성 값에 따라 스타일 바인딩 적용
    - :class='{ 'is-done': todo.isDone }'
  - forEach를 활용해 하나만 찾아서 수정
    - 순회 도중 일치 항목 찾으면 직접 속성 변경
    - todos.value.forEach((todo) => ~ )
  - map를 활용
    - 모든 항목을 순회, ID가 일치하면 새 객체를 리턴
    - todos.value = todos.value.map((todo) => ~ return todo)

- 수정, 삭제 구현에 대한 2가지 관점
  - 성능과 가독성 면에서 큰 차이 X , 프로젝트나 팀 컨벤션에 따라 방식 달라짐
  - in-place 방식 (하나만 수정/삭제)
    - 배열 전체 재생성 없이 필요한 항목만 바로 수정 또는 제거
  - 전체 배열 재생성 방식
    - 배열을 순회하면서 특정 조건을 만족하지 않으면 누락
    - 필요한 변경 사항만 반영해 새로운 배열 생성 후 기존 배열에 재할당


## Local Storage
- 브라우저 내에 key-value 쌍을 저장하는 웹 스토리지 객체
- 웹 브라우저에 데이터를 영구적으로 저장할 수 있는 '개인 하드디스크'
- 특징
  - 새로 고침해도 데이터 유지
  - 쿠키와 다르게 서버로 전송 안됨
    - 쿠키: 서버가 사용자 기억하기 위해 브라우저에 남기는 정보
  - 여러 탭, 창 간에 데이터 공유 가능
- 목적
  - 사용자 설정, 상태 정보, 캐시 데이터 등을 클라이언트 측에 보관하기 위해
  - 웹사이트의 성능 향상, 사용자 경험 개선

- pinia-plugin-persistedstate
  - 