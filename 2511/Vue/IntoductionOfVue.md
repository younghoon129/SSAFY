# Vue
- 데이터가 바뀌면 화면이 '알아서' 바뀌는 Vue의 반응성 덕분에 더 이상 번거로운 DOM 조작에 신경 쓸 필요 없음

## Frontend Development
- 사용자 인터페이스(UI)와 사용자 경험(UX)을 만들고 디자인하는 것
- HTML, CSS, JavaScript 등을 활용하여 사용자가 직접 상호작용하는 부분을 개발

## Client-side frameworks
- 클라이언트 측에서 UI와 상호작용을 개발하기 위해 사용되는 JavaScript 기반 프레임워크
- 필요한 이유
    - 사용자는 이제 웹에서 즉시 통신 중
    - 현대적이고 복잡한 대화형 웹 사이트를 '웹 애플리케이션'이라 부름
    - 매우 동적인 대화형 애플리케이션을 훨씬 더 쉽게 구축할 수 있게 됨
    - 다루는 데이터 많아짐

- 필요, 강점
    - 동적, 반응적인 웹 애플리케이션 개발
        - 실시간 데이터 업데이트
    - 코드 재사용성 증가
        - 컴포넌트 기반 아키텍처
        - 모듈화된 코드 구조
    - 개발 생산성 향상
        - 강력한 개발 도구 지원

## SPA
- 단일 페이지에서 동작하는 웹 애플리케이션
- 하나의 HTML 파일 위에서 JavaScript가 필요한 부분만 교체하며 '진짜' 페이지 이동 없이 동작
- 하나의 무대에서 배우와 배경만 계속 바꾸는 연극과 같음
- 작동 원리
    - 최초 로드 시, 어플리케이션에 필요한 주요 리소스를 다운로드
    - 페이지 갱신에 대해 필요한 데이터만을 비동기적으로 전달 받아 화면의 필요한 부분만 동적으로 갱신
        - AJAX와 같은 기술을 사용하여 필요한 데이터만 비동기적으로 로드
        - 페이지 전체를 다시 로드할 필요 없이, 필요한 데이터만 서버로부터 가져와서 화면에 표시
    - JavaScript를 사용하여 클라이언트 측에서 동적으로 콘텐츠를 생성하고 업데이트
        - CSR 방식

## CSR
- 클라이언트에서 콘텐츠를 렌더링하는 방식
- 빈 집(HTML)에 들어간 뒤, 가구(JavaScript)를 배송받아 직접 조립하는 방식
- JavaScipt가 실행되어 데이터를 요청하고 화면을 동적으로 완성
- 작동원리
    - 사용자가 웹사이트에 요청 보냄
    - 서버는 최소한의 HTML과 JavaScript 파일을 클라이언트로 전송
    - 클라이언트는 HTML과 JavaScript를 다운
    - 브라우저가 JavaScript를 실행하여 동적으로 페이지 콘텐츠를 생성
    - 필요한 데이터는 API를 통해 서버로부터 비동기적으로 가져옴
        - 서비스에서 페이지 갱신 시 새로고침이 없는 이유

- CSR과 SPA의 장점
    - 빠른 페이지 전환
        - 페이지가 처음 로드된 후에는 필요한 데이터만 가져오면 되고 JavaScript는 전체 페이지를 새로 고칠 필요 없이 페이지의 일부를 다시 렌더링할 수 있기 때문
        - 서버로 전송되는 데이터의 양을 최소화(서버 부하 방지)
    - 사용자 경험(UX)
        - 새로고침이 발생하지 않아 네이티브 앱과 유사한 사용자 경험을 제공
    - Frontend와 Backend의 명확한 분리
        - Frontend는 UI 렌더링 및 사용자 상호 작용 처리를 담당, Backend는 데이터 및 API 제공을 담당
        - 대규모 애플리케이션을 더 쉽게 개발하고 유지 관리 가능
    
- CSR과 SPA의 단점
    - 느린 초기 로드 속도
        - 전체 페이지를 보기 전에 약간의 지연을 느낄 수 있음
        - JavaScript가 다운로드, 구문 분석 및 실행될 때까지 페이지가 렌더링 되지 않기 때문
    - SEO(검색 엔진 최적화)문제
        - 페이지를 나중에 그려 나가는 것이기 때문에 검색에 잘 노출되지 않을 수 있음
        - 검색엔진 입장에서 HTML을 읽어서 분석해야 하는데 아직 콘텐츠가 모두 존재하지 않기 때문
    - 초기 로딩 속도 느리지만, 초기 로딩만 끝나고 나면 훌륭한 UX 경험을 주는 장점이 단점을 상쇄
    - 해결0
        - Next.js, Nuxt.js 같은 하이브리드 프레임워크를 통해 대부분 해결할 수 있게 되었다.

- SPA vs MPA / CSR vs SSR
    - Multi Page Application (MPA)
        - 여러 개의 HTML 파일이 서버로부터 각각 로드
        - 사용자가 다른 페이지로 이동할 때마다 새로운 HTML 파일이 로드됨
    - Server-side Rendering (SSR)
        - 서버에서 화면을 렌더링 하는 방식
        - 모든 데이터가 담긴 HTML을 서버에서 완성 후 클라이언트에게 전달

## VUE
- 사용자 인터페이스를 구축하기 위한 JavaScript 프레임워크
- 데이터가 바뀌면 화면도 자동으로 바뀌는 반응성이 가장 큰 특징, 직관적
- Vue 3 -> composition API
- 학습 이유
    - 낮은 학습 곡선
        - 간결, 직관적인 문법(React, Angular보다 쉬움)
        - 잘 정리된 문서를 기반으로 쉬운 학습
    - 확장성과 생태계
        - 다양한 플러그인과 라이브러리를 제공하는ㄴ 높은 확장성
        - 전세계적으로 활성화된 커뮤니티를 기반으로 많은 개발자들이 새로운 기능을 개발하고 공유함
    - 유연성 및 성능
        - 작은 규모의 프로젝트부터 대규모의 애플리케이션까지 다양한 프로젝트에 적합
    - 주목받는 Client-side framework
- 주요 특징 정리
    - 반응형 데이터 바인딩
        - 데이터 변경 시 자동 UI 업데이트
    - 컴포넌트 기반 아키텍처
        - 재사용 가능한 UI 조각
    - 간결한 문법과 직관적인 API
        - 낮은 학습 곡선
        - 높은 가독성
    - 유연한 스케일링
        - 작은 프로젝트부터 대규모 애플리케이션까지 적합
- 핵심 기능
    - 선언적 렌더링
        - 표준 HTML을 확장하는 Vue '템플릿 구문'을 사용하여 JavaScript 상태(데이터)를 기반으로 화면에 출력될 HTML을 선언적으로 작성
    - 반응성
        - JavaScript 상태 변경을 추적, 변경사항이 발생하면 자동으로 DOM을 업데이트

## Component
- 재사용 가능한 코드 블럭(개별)
- UI를 독립적이고 재사용 가능한 일부분으로 분할하고 각 부분을 개별적으로 다룰 수 있음
- 자연스럽게 애플리케이션은 중첩된 Component의 트리 형태로 구성됨

## Cue tutorial
- 사용 방법
    1. 'CDN' 방식
    2. 'NPM' 설치 방식 (Node.js 이용)
        - CDN 방식 이후 진행

## 반응형
- ref
    - 반응형 상태(데이터)를 선언하는 함수
    - JavaScript 변수를 Vue가 변화를 감지할 수 있는 반응형 객체로 만들어줌
    - 컴포넌트 내에서 변하는 값의 상태(데이터)를 추적하고 관리하기 위해 사용
    - 함수
        - .value 속성이 있는 ref 객체로 래핑하여 반환하는 함수
        - ref로 선언된 변수의 값이 변경되면, 해당 값을 사용하는 템플릿에서 자동으로 업데이트
        - 인자는 어떠한 타입도 가능
        - 템플릿의 참조에 접근하려면 setup 함수에서 선언 및 반환 필요
        - 편의상 템플릿에서 ref를 사용할 때는 .value를 작성할 필요 없음 (자동으로 언래핑 됨)
        - 즉 ref 함수는 반응형을 가지는 참조 변수를 만드는 것
        - .value: JS 내부에서 ref 값에 접근 할 때
        - 변수명: HTML 에서 값을 표시할 때
- Vue 기본 구조
    - createApp()에 전달되는 객체는 Vue 컴포넌트
    - 컴포넌트의 상태는 setup() 함수 내에서 선언되어야 하며 객체를 반환해야 함(return)

- 템플릿 렌더링
    - 반환된 객체의 속성은 템플릿에서 사용할 수 있음
    - Mustache syntax({{}})를 사용하여 메시지 값을 기반으로 동적 텍스트를 렌더링
    - 콘텐츠는 식별자나 경로에만 국한되지 않으며 유효한 JavaScript 표현식을 사용 가능

- Event Listeners in Vue
    - 'v-on' dirrective를 사용하여 DOM 이벤트 수신 가능
        - 예시: <button v-on:click='increment'>
    - 함수 내에서 반응형 변수를 변경하여 구성 요소 상태를 업데이트
    - html에서 쓸거면 return 에 적어야 됨

- ref 객체 필요 이유
    - 일반적인 변수 아닌 객체 데이터 타입으로 사용하는 이유
        - Vue 사용할 땐 직접적인 DOM 조작 하지 않는게 좋음 -> V-DOM 과 DOM 조작 차이 발생함에 따라 원하는 동작 안할 수도 있음
        - Vue는 템플릿에서 ref를 사용하고 나중에 ref의 값을 변경하면 **자동으로 변경 사항을 감지**하고, 그에 따라 DOM을 업데이트 ('의존성 추적 기반의 반응형 시스템')
    - Vue는 렌더링 중에 사용된 모든 ref를 추적, 이후 ref의 값이 변경되면 해당 ref를 사용하는 컴포넌트를 다시 렌더링
    - 이를 위해서 참조 자료형의 객체 타입으로 구현
        - JavaScript에서는 일반 변수의 접근 또는 변형을 감지할 방법이 없기 때문
        - 내부적 로직에서 필요한 변수면 ref 안해도 되긴 함. -> 근데 화면에 실시간 반영해야 된다? 그럼 ref

## Ref Unwrap 주의사항
- 템플릿에서의 unwrap은 ref가 setup에서 반환된 객체의 최상위 속성일 경우에만 적용
- object는 최상위 속성이지만 object.id는 그렇지 않음
- 표현식을 평가할 때 object.id가 unwrap 되지 않고 ref 객체로 남아 있기 때문
- 해결 방법
    - id 에 object를 구조분해할당한 후에 id를 최상위 속성으로 함
    - {{id + 1}} 이런 식으로