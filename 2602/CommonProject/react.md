# React
- useState
- useEffect
- api

## useState
- useState(상태)
    - 컴포넌트의 기억력
    - 컴포넌트 내부에서 변할 수 있는 데이터를 의미
    - 값이 변하면 리액트가 감지 후 화면을 자동으로 다시 그려줌(Re-render)
    - Hook: useState
    - 특징  
        - 변수처럼 직접 값을 수정해선 안됨, 반드시 **전용 수정 함수(Setter)를 사용해야 됨**
    - 예시
        - const [count, setCount] = useState(0); // [현재값, 수정함수]
    - 참고자료
        - https://ko.react.dev/learn/state-a-components-memory

- 핵심
  - 반응성
    - 상태가 업데이트되면 해당 상태를 사용하는 UI 부분이 즉각적으로 바뀜
  - 비동기성
    - 상태 업데이트는 예약제로 동작
    - 코드를 실행하자마자 바로 다음 줄에서 바뀐 값을 확인하려고 하면 예전 값이 나올 수 있음
  - 컴포넌트 로컬
    - 기본적으로 각 컴포넌트만의 독립적인 데이터
- 장단점
  - 장점
    - 선언적 UI
      - '데이터가 이렇게 바뀌면 화면은 이렇게 보여라'라고 선언만 하면 됨
      - 많은 DOM 조작 코드 필요하지 않음
    - 동기화
      - 데이터와 화면이 항상 일치
      - '데이터는 바뀌었는데 화면은 그대로네?' 하는 버그가 대부분 사라짐
  - 단점
    - 리렌더링 비용
      - 상태가 너무 자주 바뀌거나, 너무 상위 컴포넌트에서 관리되면 하위의 수많은 컴포넌트가 불필요하게 다시 그려질 수 있음
    - 상태 추적의 어려움
      - 컴포넌트가 복잡해지고 상태가 여기저기 흩어질 경우, '누가 이 값을 바꿨지?'를 찾기 힘들어짐
        - Redux, Zustand 같은 라이브러리 사용 이유
- 실전 코드 작성법
  - useState 훅 사용
  - 객체나 배열의 상태를 바꿀 때
    - 기존 것과 다른 객체가 들어와야 변화를 감지함
    - 즉 내용을 직접 수정해선 안됨
- 실전 사례
  - 입력 폼
    - 사용자가 타이핑하는 글자를 실시간으로 저장할 때
  - 토글
    - 메뉴가 열려있는지, 닫혀있는지 여부
  - 데이터 로딩
    - 서버에서 데이터를 받아오는 중인지, 완료됐는지 관리
  - 다크 모드
    - 현재 테마 상태 저장

- 중요
  - 상태가 곧 화면이라는 공식
  - 바닐라 JS에서는 어떻게 화면을 바꿀지 고민했다면
  - 리액트에서는 무엇을 데이터로 정의할지 고민해야됨




## Effect
- Effect(렌더링 외의 작업)
    - 리액트 컴포넌트가 화면에 나타난 후(Mount), 사라질 때(Unmount), 혹은 특정 값이 바뀔 때 실행되는 **부수 효과(Side Effect)**를 말함
    - Hook: useEffect
    - 핵심
        - 의존성 배열
        - useEffect(fn, [])
            - 화면에 처음 나타날 때 딱 한번만 실행(API 호출에 주로 사용)
        - useEffect(fn, [data])
            - data 값이 바뀔 때마다 실행
    - 예시
        - 타이머 시작, 이벤트 리스너 등록, API 호출 등
    - 참고자료
        - [Effect와 동기화하기](https://ko.react.dev/learn/synchronizing-with-effects)

## API
- fetch나 axios 라이브러리를 사용해 데이터를 가져옴
- 흐름
    - 비어있는 State 생성
    - useEffect 안에서 API를 호출
    - 받아온 데이터를 setData로 State에 삽입
    - 화면 자동 반영