# 큐

## 큐

- 큐

    * 대기줄, 등등 은 큐 문제임
    * 스택과 같이 삽입(맨 뒤)과 삭제(맨 뒤)의 위치가 제한적인 자료구조
        * 큐의 뒤에서는 삽입만 하고, 큐의 앞에서는 삭제만 이루어지는 구조
    * 선입선출
        * 큐에 삽입한 순서대로 원소가 저장되어, 가장 먼저 삽입된 원소는 가장 먼저 삭제됨
    * 큐의 주요 연산
        * 엔큐 (EnQueue)
            * 큐의 뒤쪽에 원소를 삽입하는 연산
        * 디큐(DeQue)
            * 큐의 앞쪽에서 원소를 삭제하고 반환하는 연산
        * IsEmpty
            * 큐가 공백상태인지를 확인하는 연산
        * IsFull
            * 큐가 포화상태인 지를 확인하는 연산
        * peek
            * 큐의 앞쪽에서 원소를 삭제 없이 반환하는 연산
    
    * 선형 큐는 리스트의 앞부분에 활용할 수 있는 공간이 있음에도 활용할 수 없음.
    * 포인터 두개 필요함(투 포인터 느낌)
        * 머리(front)
            * 저장된 원소 중 첫 번째 원소
            * 삭제된 위치
            * front = rear = -1
                -> (비어있는 상태)
            
        * 꼬리(back)
            * 저장된 원소 중 마지막 원소
            * 삽입되는 위치
    

- 원형 큐

    * 선형 큐는 리스트의 앞부분에 활용할 수 있는 공간이 있음에도 활용할 수 없음.
        * 해결방법 1
            * 연산이 이루어질 때마다 배열의 앞부분으로 모두 이동시킴
            * 원소 이동에 많은 시간이 소요되어 효율성이 급격히 떨어짐
        * 해결방법 2
            * 논리적으로 배열의 처음과 끝을 연결하여 원형 형태의 큐를 이룬다고 가정하고 사용
            * % 이용
    
    * 원형 큐 작동원리
        * 공백 상태와 포화 생태의 구분을 위해 front가 있는 자리는 사용하지 않고 항상 빈자리로 둠
            -> rear + 1 == front -> 가득찼다.
            -> rear == front -> 비어있다.
        * rear가 front 한 칸 전에 있으므로 포화 상태
          
        * 삽입 위치
            * 선형큐 : rear = rear + 1
            * 원형큐 : rear = (rear + 1) mod(나머지) n(큐의 크기)
    