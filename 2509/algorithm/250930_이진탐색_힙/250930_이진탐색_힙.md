# BST(이진트리), heap(힙)

## BST
- 키포인트
    * 최대 2개의 자식을 가짐
    * 순서속성을 가짐
        * 왼쪽 자식 노드 키 값 < 부모 노드 키 값
        * 오른쪽 자식 노드 키 값 > 부모 노드 키 값
- 빠른 탐색의 필요성
    * 대량의 데이터를 다루게 되면서 데이터를 효율적으로 저장, 검색, 수정하는 것이 중요
    * 선형 데이터 구조의 한계
        * 배열: 데이터 삽입/삭제가 비효율적 (O(n))
        * 연결 리스트: 검색이 비효율적 (O(n))
        * 데이터의 양이 많아질수록 성능이 저하됨
    
- 데이터의 저장, 검색, 삽입, 삭제를 효율적으로 처리하기 위한 자료구조
- 특징
    * 각 노드가 최대 2개의 자식을 가짐
    * 데이터를 정렬된 형태로 저장하여 탐색/삽입/삭제를 효율적으로 수행
    * 중위순회하면 정렬된 값을 얻을 수 있다.
- 구조
    * 순서속성을 가짐
        * 왼쪽 자식 노드 키 값 < 부모 노드 키 값
        * 오른쪽 자식 노드 키 값 > 부모 노드 키 값
- 장점
    *배열이나 링크드 리스트와 달리, 삽입/삭제 후에도 데이터가 정렬된 상태를 유지
    * 데이터가 균형 있게 분포되어 있을 때 평균적으로 탐색/삽입/삭제 연산의 시간복잡도 O(log N)
    * 동적으로 크기를 조정할 수 있어, 크기가 고정된 배열에 비해 유연성이 높음
- 단점
    * 트리가 한쪽으로 치우치면(즉, 균형이 맞지 않으면) 최악의 경우, 시간 복잡도 O(n) 될 수 있음
    * 각 노드는 두 개의 자식 포인터를 저장해야 하므로, 큰 데이터 집합의 경우 메모리 오버헤드 발생할 수 있음
- 속성
    * 높이
        * 특정 노드에서 가장 깊은 리프 노드까지의 경로에 있는 간선의 개수
        * 균형 잡힌 트리의 높이는 O(log N), 불균형 트리의 높이 O(N)
    * 깊이
        * 루트 노드에서 해당 노드까지의 경로에 있는 간선의 수
- BST_탐색
    * 
- 삽입
    * 자식 노드 최대 2개를 유지하며, 삽입할 위치를 찾기 위해 루트노드에서부터 적절한 위치까지 내려감
    * 루트 노드에서부터 삽입 위치를 담색하며 현재 노드와 삽입 노드를 비교
- 삭제
    * 삭제하려는 노드의 위치와 자식 노드의 유무에 따라 세 가지 경우로 나누어 처리
    * 삭제할 노드가 (리프, 한 개의 자식 노드 가질 경우, 두 개의 자식 노드를 가질 경우)
    * 삭제할 노드가 리프 노드일 경우 그냥 지움
    * 한 개의 자식을 가진 경우 삭제할 노드의 자식 노드를 부모 노드에 연결
        * 각 서브트리는 독립적으로 존재하여, BST 속성이 유지
    * 두 개의 자식을 가진 경우, 중위 후속자 또는 중위 전임자 찾기
        * 중위 후속자 : 삭제할 노드의 오른쪽 서브 트리에서 가장 작은 값(일반적으로 사용)
        * 중위 전임자 : 삭제할 노드의 왼쪽 서브 트리에서 가장 큰 값
        * BST 구조를 유지하기 위해서 삭제할 노드와 가장 가까운 값을 찾는 것
- 문제점
    * BST의 구조는 삽입되는 데이터의 순서에 따라 결정되기 때문에 특정 패턴으로 삽입 되는 경우 불균형이 발생
        * 불균형한 BST의 문제점
        * 검색/삽입/삭제 연산의 시간복잡도가 O(N)이 됨 (균형 일 경우 O(log N))
        * 트리의 높이가 증가하게 되면서 많은 메모리 공간이 필요
        * 트리의 높이가 증가하게 되면서 깊이 있는 재귀호출로 인해서 스택 오버플로우 발생할 수 있음
    * 불균형 문제 해결할 수 있는 방법
        * 자가 균형 트리
            * AVL 트리 (색상 + 회전) - 유연성 높지만, 속도 느릴 수 잇음
            * 레드-블랙 트리
    
## heap
- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 키 값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대 힙
    * 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
    * 부모 노드의 키 값 > 자식 노드의 키 값
    * 루트 노드: 키 값이 가장 큰 노드
    * 순서 속성X, 부모 > 자식(최대 힙 기준)
- 최소 힙
    * 순서 속성X, 부모 > 자식(최소 힙 기준)
- 힙의 삽입 과정
    * 새로운 원소를 heap의 마지막 위치(리스트의 끝)에 추가
    * 새로 추가된 원소를 부모 노드와 비교
    * 시간
        * 최선 : O(1)
        * 평균/최악 : O(logN)
- 힙의 삭제 과정
    * 루트 노드의 원소만 삭제할 수 있음
    * 루트 노드(최대값 또는 최소값)를 제거하고, 힙의 마지막 요소를 루트 위치로 이동한다.
    * 새 루트를 자식 노드들과 비교하며, 힙 속성을 만족할 때까지 아래로 내린다.
    * 시간
        * 최선: O(1)
        * 평균/최악 : 0(logN)

- heapq
    * 최소 힙을 구현한 라이브러리
    * heapq.heapify(X): 리스트 x를 heap으로 변환 O(N)
    * heapq.heappush(heap, item)
    * heapq.heappop
    