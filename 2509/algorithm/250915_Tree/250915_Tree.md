# Tree
- 데이터를 노드(node)라고 표현
- 비선형 자료구조(순서가 없다)
- 원소들 간에 1:n 관계
- 계층형 자료구조
    * 상위 -> 하위 내려가면서 확장되는 트리모양 구조
- 한 개 이상의 노드로 이루어진 유한 집합 (노드란 -> 트리의 데이터(원소))
    * 노드 중 최상위 노드를 루트라 함
    * 나머지 노드들은 분리집합 될 수 있음(부 트리)
    * 단말 노드, 잎 노드
        * 가장 아래 있는 노드
- 일관성이 없어 규칙 찾기 어렵다

## 트리 용어
- 노드 ***
    * 트리의 원소
- 간선(관계) ***
    * 노드와 노드를 연결하는 선
    * 부모 노드와 자식 노드 연결
- 루트 노드 ***
    * 최상위 노드
- 형제 노드
    * 같은 부모 노드의 자식 노드들
- 조상 노드
    * 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브 트리
    * 부모 노드와 연결된 간선을 끊었을 때 생성되는 트리
- 자손 노드
    * 서브 트리에 있는 하위 레벨 노드
- 차수(degree)*****
    * 노드의 차수 ***
        * 노드에 연결된 자식 노드 수
    * 트리의 차수
        * 트리에 있는 노드의 차수 중 가장 큰 값
    * 단말 노드 ***
        * 차수가 0, 자식노드 없는 노드
- 레벨
    * 루트에서 노드까지의 거리
- 높이 *****
    * 루트 노드에서 가장 먼 리프 노드까지의 간선 수
    * 트리의 높이는 최대 레벨


## 이진 트리
- 모든 노드들이 최대 2개의 서브 트리를 갖는 특별한 형태의 트리(차수가 2인 트리)
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
    * 왼쪽 자식 노드
    * 오른쪽 자식 노드
- 특성
    * 레벨 i 에서의 노드의 최대 개수는 2**i 개


## 포화 이진 트리
- 모든 레벨에 노드가 포화 상태로 차 있는 이진 트리
    * 리프 노드 제외 모두 2개씩 자식 갖고 있음
- 높이가 h일 때, 최대 노드 개수인 (2**h+1-1)의 노드를 가진 이진 트리
- 루트를 1번으로 하여 2**h+1-1까지 정해진 위치에 대한 노드를 가짐


## 완전 이진 트리
- 높이가 h이고 노드 수가 n일 때 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리 


## 편향 이진 트리
- 한쪽 방향의 자식 노드 만을 가진 이진 트리
    * (왼,오른쪽) 편향 이진 트리


## 리스트를 이용한 이진 트리 구현
- 단점
    * 편향 이진 트리의 경우 사용하지 않는 리스트 원소에 대한 메모리 공간 낭비 발생
    * 트리 중간에 새로운 노드를 삽입 및 삭제할 경우 리스트의 크기 변경이 어려워 비효율적
- 루트 노드를 번호 1부터 시작해야 아래 함수 가능, 번호 변경 시 함수도 변경 필요
    - def insert(self, value)
        * 데이터 삽입(append)
    - def get_node(self, index)
        * 해당하는 노드들을 가져오는 것(트리의 길이보다 작아야됨, 그렇지 않으면 None을 반환)
    - def set_node(self, index, value)
        * 데이터를 저장하는 것, 저장하고 싶은 해당 인덱스에 도달할 때까지 while로 None을 append
    - def get_left_child(self, index)
        * left_index = 2 * index
    - def get_right_child(self, index)
        * right_index = 2 * index + 1
    - def get_parent(self, index)
        * parent_index = index // 2


## 이진 트리의 연결 리스트 표현
- 리스트 이진 트리 단점 보완
- 일정한 구조의 이중 연결 리스트 노드 사용
- 루트의 번호를 1로 함, 레벨 n에 있는 노드에 2**((n+1)-1)
- 노드번호가 i일 때
    * 부모 노드번호: i/2
    * 왼 자식 노드 : 2*i
    * 오 자식 노드 : 2*i+1
- 높이가 h인 이진 트리를 위한 배열의 크기
    * 레벨 i의 최대 노드 수 : 2**i

    
## 이진 트리 순회
- 순회란 트리의 각 노드를 중복되지 않게 전부 방문 하는 것
    * 단, 트리는 비선형 구조 이기 때문에 선후 연결 관계를 알 수 없다.
    * 트리에서 순회 : 트리의 노드들을 체계적으로 방문(V = 루트, L = 왼, R = 오)
        * 각 용어의 기준은 루트 노드
        * def preorder_traversal(root)
            if root:
                print(root.val)
                preorder_traversal(root.left)
                preorder_traversal(root.right)
        - 전위순회(VLR)
            * 부모 노드 방문 후, 자식 노드를 좌, 우 순서 방문
            * 사용 용도
                * *탐색*
                * 파일 시스템, 검색(밑으로 내려가며 탐색할 때)

        - 중위순회(LVR)
            * 왼쪽 자식 노드, 부모 노드, 오른쪽 자식 노드 순서 방문
            * 사용 용도
                * *순서*
                * 정렬, 트리(비선형)를 정해진 순서대로 탐색하고 싶을 때(왼 -> 오 접근가능)
        - 후위순회(LRV)
            * 자식 노드를 좌우 순서로 방문한 후, 부모 노드 방문
            * 사용 용도
                * 가장 안 쪽부터 접근(삭제 및 파일 크기 확인 등)
                * 루트를 가장 마지막에 확인하기 때문에 가장 안쪽에 있는 원소에 접근할 수 있다는 장점이 있음
                * 디렉토리의 총 크기(하위에서 올라가면서 계산), 디렉토리 삭제(맨 아래서부터 올라가며 삭제)
                * C, C++ 관리할 때 (루트를 먼저 지우면 안쪽 원소에 접근할 방법이 없음 -> 메모리 누수)


## 수식 트리
- 연산자는 루트 노드이거나, 가지 노드
- 피연산자는 모두 잎 노드


## DFS
- 루트 노드에서 출발하여 한 방향으로 갈 수 있는 경로가 있는 곳까지 깊이 탐색
- 갈 곳 없게 되면, 가장 마지막 갈림길 간선으로 돌아와 다른 방향 탐색 반복, 모든 노드 방문
    * 되돌아가고 깊이 우선 탐색 반복해야 하므로 재귀적 or 후입선출 구조의 스택 사용 
- if node not in tree:
    return
    * -> 리프 노드(단말 노드), 자식이 0인 노드
