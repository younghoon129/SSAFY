# 복습
- 트리
    * 1:N
    * 계층구조(레벨o)
    * 루트 O
    * 싸이클 x
- 그래프
    * N:M
    * 네트워크(레벨x)
    * 루트 X (전부 시작점)
    * 싸이클 O (매우중요)
        * 한 정점에서 시작해서 자기 자신으로 돌아오면 싸이클 있다로 봄
        * 최단경로(마이너스 경로)
        * 위상정렬(의존성)

# 서로소 집합(Disjoint-set)
- 서로 중복 포함된 원소가 없는 집합(교집합 X)


## 서로소 집합 표현: 연결 리스트
- 맨 앞의 원소를 집합의 대표 원소로 삼음
- 각 원소는 집합의 대표원소를 가리키는 링크를 갖는다.
- find-set() -> O(1)
- union-set() -> O(N)


## 서로소 집합 표현: 트리
- 같은 집합의 원소들을 하나의 트리로 표현
- 자식 노드가 부모 노드를 가르키며 루트 노드가 대표자가 됨
- 자식끼리 Union 하면 부모끼리 비교 후에 더 낮은 부모가 큰 부모에 산하로 들어감
- 서로소 집합 연산 다시보기
    * 사이클 있다?
    * C는 간선 2개?
    * -59
    * -41분

## 서로소 집합 연산
- make_set(?)
- find_set(?)
- Union_set(?)


## 서로소 집합 연산 최적화
- path compression
    * Find-set 과정에서 모든 노드들이 root를 가리키도록 포인터함(O(N)으로 변경)
    * 무조건 O(N) 한번 실행하면서 부모갱신하고 다음번에 부모 찾을 땐 O(1)
- Rank를 이용한 Union
    * 각 노드는 자신을 루트로 하는 subtree의 높이를 rank로 저장
    * 두 집합을 합칠 때 rank가 낮은 집합을 rank가 높은 집합에 붙인다.
        * 만약 같으면? 개발자 마음 
        * 그리고 깊이(자식)이 하나 늘었으니까 (rank+= 1)

- 최적화를 쫙 해주는 느낌이 path compression이랑 다른 점?