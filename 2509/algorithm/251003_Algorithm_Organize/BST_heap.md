16:12
# BST, heap
- 빠른 탐색의 필요성
    * 대량의 데이터를 다루게 되면서 데이터를 효율적으로 저장, 검색, 수정하는 것이 중요
    * 선형 데이터 구조의 한계
        * 배열: 데이터 삽입/삭제가 비효율적 O(n)
        * 연결 리스트: 검색이 비효율적 O(n)
        * 데이터의 양이 많아질수록 성능이 저하됨

## BST
- 탐색, 삽입, 삭제
    * 데이터의 저장, 검색, 삭제를 효율적으로 처리하기 위한 자료구조
    * 특징
        * 각 노드가 최대 2개의 자식을 가짐
        * 데이터를 정렬된 형태로 저장하여 탐색/삽입/삭제를 효율적으로 수행
    * 구조
        * 이진 트리의 특성 + 순서속성
        * 순서속성
            * 왼쪽 자식 노드의 키 값이 부모 노드의 키 값보다 작음
            * 오른쪽 자식 노드의 키 값이 부모 노드의 키 값보다 큼
    * 장점
        * 배열, 링크드 리스트와 차이: 삽입/삭제 후에도 데이터가 정렬된 상태를 유지
        * 데이터가 균형 있게 분포되어 있을 때 평균적으로 탐색/삽입/삭제 연산의 시간복잡도가 O(logN)
        * 동작으로 크기를 조정할 수 있어, 크기가 고정된 배열에 비해 유연성이 높음
    * 단점
        * 트리가 한쪽으로 치우치면(즉, 균형이 맞지 않으면) 최악의 경우, 시간 복잡도가 O(n)이 될 수 있음 - 불균형이면 하나하나 다 지나가면서 탐색해야 되니까
        * 각 노드는 두 개의 자식 포인터를 저장해야 하므로, 큰 데이터의 집합의 경우 메모리 오버헤드 발생 가능성
    * 속성
        * 높이
            * 특정 노드에서 가장 깊은 리프 노드까지의 경로에 있는 간선의 개수
            * 트리의 높이는 루트 노드의 높이와 동일
            * 리프 노드의 높이는 0
            * 균형 잡힌 트리의 높이는 O(logN), 불균형 O(N)
        * 깊이
            * 루트 노드에서 해당 노드까지의 경로에 있는 간선의 수
            * 루트 노드는 0

- 주요 연산
    * 탐색
        * 순서 속성을 이용하여 키 값을 비교하며(왼쪽, 오른쪽) 주어진 키 값을 찾는 과정
    * 삽입
        * BST의 특징(자식노드 2개) 유지하며 루트노드 부터 삽입할 위치를 찾으러 내려감
        * 순서 속성을 유지하기 위해 새로운 노드는 리프 노드로 삽입
    * 삭제
        * 삭제할 노드 탐색하는데 탐색 연산과 같음
        * 삭제하려는 노드의 위치와 자식 노드의 유무에 따라 3가지
            * 리프인 경우
                * 그냥 삭제
            * 한개의 자식
                * 삭제할 노드의 자식 노드를 부모 노드에 연결(서브트리는 독립적, BST 속성 유지)
            * 두개의 자식
                * BST 구조 유지하기 위해 삭제할 노드와 가장 가까운 값으로 설정
                * 중위 후속자
                    * 삭제할 노드의 오른쪽 서브 트리에서 가장 작은 값
                * 중위 전임자
                    * 삭제할 노드의 왼쪽 서브 트리에서 가장 큰 값        
- 정리
    * BST는 탐색 작업을 효율적으로 하기 위한 자료구조
        * O(logN)
    * 모든 원소는 서로 다른 유일한 키를 갖는다.
    * 왼key < 루트key < 오른key
    * 각 서브트리도 이진탐색트리이다
    * 중위 순회시 오름차순 정렬된 값 얻을 수 있다
- 단점
    * 데이터의 삽입 순서에 따라 BST구조 결정됨
        * -> 특정 패턴으로 삽입되는 경우 불균형
    * 불균형 BST 문제
        * 시간복잡도 O(N)
        * 트리 높이 증가(많은 메모리 공간 필요)
        * 깊이 있는 재귀호출로 인해 스택 오버플로우 가능성
- 해결 방법
    * 자가 균형 트리
        * AVL
        * 레드-블랙


## heap
- 삽입, 삭제, heapq 모듈, 우선순위 큐
- 완전 이진 트리에서 키 값이 가장 크거나 작은 노드를 구하기 위한 자료구조
- 최대 힙
    * 키 값 가장 큰 노드를 찾기 위한 완전 이진 트리
    * 부모 노드의 키 값 > 자식 노드의 키 값
    * 루트 노드: 키 값이 가장 큰 노드
- 최소 힙
- 삽입 과정
    * 새로운 원소를 heap의 마지막 위치에 추가
    * 새로 추가된 원소를 부모 노드와 비교하며, 힙 속성을 만족할 때까지 위로 올린다.
    * 시간 복잡도
        * 최선: O(1)
        * 평균/최악: O(logN)
- 삭제 과정
    * 힙에서는 루트 노드의 원소만을 삭제할 수 있음
    * 루트 노드를 제거하고, 힙의 마지막 요소를 루트 위치로 이동한다
    * 새 루트를 자식 노드들과 비교하며, 힙 속성을 만족할 때까지 아래로 내린다
    * 시간 복잡도
        * 최선: O(1)
        * 평균/최악: O(logN)
- heapq 모듈
    * 최소 힙을 구현한 라이브러리
    * heap 함수의 활용
        * heapq.hepaify(x)
        * heapq.heappush(heap, item)
        * heapq.heappop(heap)
    * 모든 값을 음수로 변환하여 최대 힙처럼 사용
